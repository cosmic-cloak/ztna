syntax = "proto3";

package ztna.ctrl.pb;
option go_package = "github.com/openziti/fabric/pb/ctrl_pb";

// ContentTypes should be in the range 1000 - 1999, to ensure they don't overlap with cmd_pb messages
enum ContentType {
  Zero = 0;

  CircuitRequestType = 1000;
  // defined in ctrl_msg/messages.go now
  // CircuitSuccessType = 1001;
  DialType = 1002;
  LinkConnectedType = 1003;
  FaultType = 1004;
  RouteType = 1005;
  UnrouteType = 1006;
  MetricsType = 1007;
  TogglePipeTracesRequestType = 1008;
  TraceEventType = 1010;
  CreateTerminatorRequestType = 1011;
  RemoveTerminatorRequestType = 1012;
  InspectRequestType = 1013;
  InspectResponseType = 1014;
  // defined in ctrl_msg/messages.go now
  // CircuitFailedType = 1016;
  ValidateTerminatorsRequestType = 1017;
  UpdateTerminatorRequestType = 1018;
  // VerifyLinkType = 1019; Unusable since links are now generated by routers
  SettingsType = 1020;
  CircuitConfirmationType = 1034;
  RouterLinksType = 1035;
  VerifyRouterType = 1036;
  UpdateCtrlAddressesType = 1037;

  RemoveTerminatorsRequestType = 1038;
  QuiesceRouterRequestType = 1039;
  DequiesceRouterRequestType = 1040;
  ValidateTerminatorsV2RequestType = 1041;
  ValidateTerminatorsV2ResponseType = 1042;
  DecommissionRouterRequestType = 1043;

  PeerStateChangeRequestType = 1050;
  UpdateClusterLeaderRequestType = 1051;
}

enum ControlHeaders {
  NoneHeader = 0;
  ListenersHeader = 10;
  RouterMetadataHeader = 11;
  CapabilitiesHeader = 12;
}

enum RouterCapability {
  CapabilityZero = 0;
  LinkManagement = 1;
}

// SettingTypes are used with the Settings message send arbitrary settings to routers.
// SettingTypes default to int32 which can be used seamlessly for keys in the Settings.data field
enum SettingTypes {
  //unused, consume to avoid zero value accidents
  UnusedSetting = 0;
  //Sent to routers to notify them of a controller IP/hostname move
  NewCtrlAddress = 1;
}

// Settings are sent to to routers to configure arbitrary runtime settings.
message Settings {
  map<int32, bytes> data = 1;
}

message CircuitRequest {
  string ingressId = 1;
  string service = 2;
  map<uint32, bytes> peerData = 3;
}

message CircuitConfirmation {
  repeated string circuitIds = 1;
  map<string, int64> idleTimes = 2;
}

enum TerminatorPrecedence {
  Default = 0;
  Required = 1;
  Failed = 2;
}

message CreateTerminatorRequest {
  string serviceId = 2;
  string binding = 3;
  string address = 4;
  map<uint32, bytes> peerData = 5;
  uint32 cost = 6;
  TerminatorPrecedence precedence = 7;
  string instanceId = 8;
  bytes instanceSecret = 9;
}

message RemoveTerminatorRequest {
  string terminatorId = 1;
}

message RemoveTerminatorsRequest {
  repeated string terminatorIds = 1;
}

message Terminator {
  string id = 1;
  string binding = 2;
  string address = 3;
  uint64 marker = 4;
}

message ValidateTerminatorsRequest {
  repeated Terminator terminators = 1;
}

message ValidateTerminatorsV2Request {
  repeated Terminator terminators = 1;
  bool fixInvalid = 2;
}

enum TerminatorInvalidReason {
  UnknownBinding = 0;
  UnknownTerminator = 1;
  BadState = 2;
}

message RouterTerminatorState {
  bool valid = 1;
  TerminatorInvalidReason reason = 2;
  string detail = 3; // inspect info if valid
  uint64 marker = 4;
}

message ValidateTerminatorsV2Response {
  map<string, RouterTerminatorState> states = 1;
}

message UpdateTerminatorRequest {
  string terminatorId = 1;
  bool updatePrecedence = 2;
  bool updateCost = 3;
  TerminatorPrecedence precedence = 4;
  uint32 cost = 5;
}

message Dial {
  string linkId = 1;
  string address = 2;
  string routerId = 3;
  string linkProtocol = 4;
  string routerVersion = 5;
}

message LinkConn {
  string id = 1;
  string localAddr = 2;
  string remoteAddr = 3;
}

message LinkConnected {
  string id = 1;
  repeated LinkConn conns = 2;
}

message RouterLinks {
  message RouterLink {
    string id = 1;
    string destRouterId = 2;
    string linkProtocol = 3;
    repeated string linkCostTags = 4;
    string dialAddress = 5;
    uint32 iteration = 6;
  }

  repeated RouterLink links = 1;
}

enum FaultSubject {
  IngressFault = 0;
  EgressFault = 1;
  LinkFault = 2;
  ForwardFault = 3;
  UnknownOwnerForwardFault = 4;
  LinkDuplicate = 5;
}

message Fault {
  FaultSubject subject = 1;
  string id = 2;
  uint32 iteration = 3;
}

message Context {
  map<string, string> fields = 1;
  uint32 channelMask = 2;
}

enum DestType {
  Start = 0;
  End = 1;
  Link = 2;
}

message Route {
  string circuitId = 1;
  uint32 attempt = 2;
  message Egress {
    string binding = 1;
    string address = 2;
    string destination = 3;
    map<uint32, bytes> peerData = 4;
  }
  Egress egress = 3;
  message Forward {
    string srcAddress = 1;
    string dstAddress = 2;
    DestType dstType = 3;
  }
  repeated Forward forwards = 4;
  Context context = 5;
  uint64 timeout = 6;
  map<string, string> tags = 7;
}

message Unroute {
  string circuitId = 1;
  bool now = 2;
}

message InspectRequest {
  repeated string requestedValues = 1;
}

message InspectResponse {
  bool success = 1;
  repeated string errors = 2;
  repeated InspectValue values = 3;

  message InspectValue {
    string name = 1;
    string value = 2;
  }
}

message VerifyRouter {
  string routerId = 1;
  repeated string fingerprints = 2;
}

message Listener {
  string address = 1;
  string protocol = 2;
  repeated string costTags = 3;
  repeated string groups = 4;
  string localBinding = 5;
}

message Listeners {
  repeated Listener listeners = 1;
}

message UpdateCtrlAddresses {
  repeated string addresses = 1;
  uint64 index = 2;
  bool isLeader = 3;
}

message UpdateClusterLeader {
  uint64 index = 1;
}

enum PeerState {
  Healthy = 0;
  Unhealthy = 1;
  Removed = 2;
}

message PeerStateChange {
  string id = 1 ;
  string version = 2;
  PeerState state = 3;
  repeated Listener listeners = 4;
}

message PeerStateChanges {
  repeated PeerStateChange changes = 1;
}

message RouterMetadata {
  repeated RouterCapability capabilities = 1;
}